<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mental Load Dev</title>
  <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Barlow:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<style>
  html * {
    font-family: "Barlow", sans-serif !important;
    overflow: visible
  }

  h1 {
    font-weight: 500;
    line-height: 1.2;
    letter-spacing: -1px;
    font-size: 60px;
    color: #003b5c;
    margin-top: 0.75em;
    margin-bottom: .75em;
  }

  h2 {
    font-weight: 500;
    line-height: 1;
    letter-spacing: 0px;
    font-size: 34px;
    color: #0092bc;
    margin-top: 0em;
    margin-bottom: 1em;
  }

  h3 {
    font-weight: 600;
    line-height: 1.5;
    letter-spacing: 0px;
    font-size: 28px;
    color: #003b5c;
    margin-top: 1.4em;
    margin-bottom: .75em;
  }

  h4 {
    font-weight: 450;
    line-height: 1.5;
    letter-spacing: 0px;
    font-size: 20px;
    color: #003b5c;
    margin-top: 1.33em;
    margin-bottom: .75em;
  }

  body {
    margin-left: 40px; 
  }

  .tooltip {
    position: absolute;
    text-align: center;
    width: auto;
    height: auto;
    padding: 5px;
    font-size: 13px;
    background: #F2F2F2;
    border: 0px;
    border-radius: 2px;
    pointer-events: none;
    visibility: hidden;
    z-index: 1;
    /* Initially hidden */
  }

  .axislabel,
  .tick,
  .annotation,
  .label {
    font-size: 14px;
  }

  .dashed_line {
    stroke: black;
    stroke-dasharray: 4 4;
    stroke-width: 1;
  }

  .sum {
    stroke:white;
    stroke-width:0.5em;
    fill:black;
    paint-order:stroke;
    stroke-linejoin:round;
    font-size: 15px;
  }

  .chart_title {
    font-size: 18px;
    font-weight: 450;
  }

  .grid line {
      stroke: lightgrey;
      stroke-opacity: 0.7;
      shape-rendering: crispEdges;
      
    }
  

  input, label {
    display:block;
    font-size: 14px;
  }

  p {
    max-width: 850px;
    font-size: 16px;
  }

  button {
    font-size: 16px;
    padding: 7px;
    
    /* background-color: #C8532E; */
    border: 0px;
    border-radius: 2px;
    cursor: pointer;
   
    /* Initially hidden */
  }
  button:hover {
    background-color: #C8532E;
  }
  button:active {
    background-color: #cb846f;
  }

  /* .tick {
  font-size: 13px;
} */
</style>

<body>


  <script>

    // Set up the SVG area and margins
    var margin = { top: 50, right: 20, bottom: 20, left: 60 };
    var width = 400 - margin.left - margin.right;
    var height = 350 - margin.top - margin.bottom;

    var language = "en"

    // append the svg object to the body of the page


    d3.json("data/test_json_en.json").then(function (data_raw) {
      //#region               ###############      variables   #################
      var all_cats = [];
      if (language == "de") {
        var rhythms_points_mapping_de = {
          "täglich": 4,
          "wöchentlich": 3,
          "monatlich": 2,
          "jährlich": 1
        }
        var rhythms = Object.keys(rhythms_points_mapping_de);
      }
      else if (language == "en") {
        var rhythms_points_mapping_en = {
          "daily": 4,
          "weekly": 3,
          "monthly": 2,
          "yearly": 1
        }
        var rhythms = Object.keys(rhythms_points_mapping_en);
      }
      const types = ["I_do_it", "I_remember"]
      const partner_types = ["partner_does_it", "partner_remembers"]


      //#endregion


      //#region                    ###############      prep and reshape data            #################
      var questions_final = []; //reshaped data
      var quest_ID = 0;
      // target data shape
      // {
      //     "Wäsche waschen + aufhängen": {
      //         "Text": "Wäsche waschen + aufhängen",
      //         "ID": "2",
      //         "domain": "Alle Sorgegemeinschaften, z.B. Paare",
      //         "category":"Haushalt + Wohnen",
      //         "rhythm": "täglich",
      //         "points": "4.00",
      //         "I_do_it": true,
      //         "I_remember": false,
      //         "not_apply": false,
      //         "partner_does_it": false,
      //         "partner_remembers": true,
      //         "I_do_it_and_I_remember": false
      //     }
      // }
      let domains = Object.keys(data_raw);
      //console.log(domains)
      for (let i = 0; i < domains.length; i++) {
        let obj_cats = data_raw[domains[i]]
        let cats = Object.keys(obj_cats)
        //console.log(obj_cats)
        //console.log(cats)
        for (let catId = 0; catId < cats.length; catId++) {
          let obj_rhthm = obj_cats[cats[catId]]
          let rhthms = Object.keys(obj_rhthm)
          //console.log(obj_rhthm)
          //console.log(rhthms)
          //something[catId] = []
          for (let rhtmID = 0; rhtmID < rhthms.length; rhtmID++) {
            let obj_question = obj_rhthm[rhthms[rhtmID]]
            let questions = Object.keys(obj_question)
            //console.log(obj_question)
            //console.log(questions)
            for (let quesID = 0; quesID < questions.length; quesID++) {
              let obj_ques_level_2 = obj_question[questions[quesID]]
              let ques_level_2 = Object.keys(obj_ques_level_2)
              let obj_arr_answers = obj_ques_level_2[ques_level_2[0]]
              //console.log(obj_ques_level_2)
              //console.log(ques_level_2[0])
              //add question to final array, and some more infos we know
              questions_final[quest_ID[0]] = []
              questions_final.push({})
              questions_final[quest_ID]["Text"] = ques_level_2[0]
              questions_final[quest_ID]["ID"] = questions[quesID]
              questions_final[quest_ID]["domain"] = domains[i].replace('... ', '')
              questions_final[quest_ID]["category"] = cats[catId]
              questions_final[quest_ID]["rhythm"] = rhthms[rhtmID]
              if (language == "de") {
                questions_final[quest_ID]["points"] = rhythms_points_mapping_de[rhthms[rhtmID]]
              }
              else if (language == "en") {
                questions_final[quest_ID]["points"] = rhythms_points_mapping_en[rhthms[rhtmID]]
              }

              //either empty array: partner does it, or object with answers 
              if (Array.isArray(obj_arr_answers)) {
                //console.log("partner does it")
                questions_final[quest_ID]["I_do_it"] = false;
                questions_final[quest_ID]["I_remember"] = false;
                questions_final[quest_ID]["partner_does_it"] = true;
                questions_final[quest_ID]["partner_remembers"] = true;
                questions_final[quest_ID]["not_apply"] = false;
                questions_final[quest_ID]["I_do_it_and_I_remember"] = false;
                //"I_do_it_and_I_remember": false//partner +=1
                //partner_rhm +=1
              }
              else {
                let obj_answers = obj_arr_answers //now an object
                let answers = Object.keys(obj_answers)
                //console.log(answers)
                //console.log(obj_answers)
                if (answers.length == 2) { //no need to go into answers, this must be "done" and "I_remembered"
                  questions_final[quest_ID]["I_do_it"] = true;
                  questions_final[quest_ID]["I_remember"] = true;
                  questions_final[quest_ID]["not_apply"] = false;
                  questions_final[quest_ID]["partner_does_it"] = false;
                  questions_final[quest_ID]["partner_remembers"] = false;
                  questions_final[quest_ID]["I_do_it_and_I_remember"] = true;
                }
                else {
                  questions_final[quest_ID]["I_do_it_and_I_remember"] = false;
                  let obj_single_answer = obj_answers[answers[0]] //only answer
                  //console.log(obj_single_answer)
                  //console.log(obj_single_answer["answer_type"])
                  switch (obj_single_answer["answer_type"]) {
                    case "1": //"I_do_it"
                      questions_final[quest_ID]["I_do_it"] = true;
                      questions_final[quest_ID]["I_remember"] = false;
                      questions_final[quest_ID]["not_apply"] = false;
                      questions_final[quest_ID]["partner_does_it"] = false;
                      questions_final[quest_ID]["partner_remembers"] = true;
                      break;
                    case "2": //"I_remember"
                      questions_final[quest_ID]["I_do_it"] = false;
                      questions_final[quest_ID]["I_remember"] = true;
                      questions_final[quest_ID]["not_apply"] = false;
                      questions_final[quest_ID]["partner_does_it"] = true;
                      questions_final[quest_ID]["partner_remembers"] = false;
                      break;
                    case "3": //"not_apply"
                      questions_final[quest_ID]["I_do_it"] = false;
                      questions_final[quest_ID]["I_remember"] = false;
                      questions_final[quest_ID]["not_apply"] = true;
                      questions_final[quest_ID]["partner_does_it"] = false;
                      questions_final[quest_ID]["partner_remembers"] = false;
                      break;
                  }
                }
              }
              quest_ID += 1;
            }
          }
        }

      }
      //questions_final.forEach((element) => console.log(element));
      //console.table(questions_final)
      //console.table(questions_final.filter(function(d) {return d.I_remember == true}))
      var valid_questions = questions_final.filter(function (d) { return d.not_apply == false })
      //console.table(valid_questions)
      let max_num_points = d3.sum(valid_questions, (d) => d.points)

      //print some stats of points
      let I_remembered_questions = questions_final.filter(function (d) { return d.I_remember == true })
      let done_questions = questions_final.filter(function (d) { return d.I_do_it == true })
      let not_apply_questions = questions_final.filter(function (d) { return d.not_apply == true })
      let partner_does_it_questions = questions_final.filter(function (d) { return d.partner_does_it == true })
      let partner_remembers_questions = questions_final.filter(function (d) { return d.partner_remembers == true })
      let I_remembered_points = d3.sum(I_remembered_questions, (d) => d.points)
      let done_points = d3.sum(done_questions, (d) => d.points)
      let partner_done_points = d3.sum(partner_does_it_questions, (d) => d.points)
      let partner_remembers_points = d3.sum(partner_remembers_questions, (d) => d.points)
      let number_not_apply = d3.count(not_apply_questions, (d) => d.ID)
      var questions_answered = d3.count(valid_questions, (d) => d.ID)
      // group by daily, monthly etc. for plots and analysis
      let grouped_by_rhythm = d3.group(valid_questions, d => d.rhythm)

      const uniqueCategories = Array.from(new Set(valid_questions.map(d => d.category)));
      const uniqueDomains = Array.from(new Set(valid_questions.map(d => d.domain)));
      //console.log(uniqueDomains)
      console.log("points done: " + done_points + ", points I_remembered: " + I_remembered_points +
        ", points done of partner: " + partner_done_points +
        ", points I_remembered of partner: " + partner_remembers_points +
        ", number not apply: " + number_not_apply +
        ", max sum of points reachable, for each category: " + max_num_points +
        ". Answered questions: " + questions_answered
      )
      // check validity of data
      if (done_points + partner_done_points != I_remembered_points + partner_remembers_points ||
        done_points + partner_done_points != max_num_points) {
        throw "something is wrong with the dataset"
      }

      //#endregion

      //#region           ############    colours    ##############
        var mntlld_darkblue = "#0F3D5F"
        var mntlld_lightblue = "#0A92BA"
        var mntlld_green = "#7FB701"
        var mntlld_grey = "#F2F2F2"
        var mntlld_dark_grey = "#ABABAB"
        var mntlld_red = "#C8532E"
        var mntlld_lightred = "#cb846f"

        var color = d3.scaleOrdinal()
          .domain(rhythms)
          .range([ //'#0d5f83', 
            '#0b81a8', '#38a5c5', '#95ccdc', 
            "#D6E4E9"])

          
        var domainColor = d3.scaleOrdinal()
          .domain(uniqueDomains)
          .range([mntlld_darkblue, mntlld_green, mntlld_red])
      //#endregion
      

      //#region                ##########  main, structure and layout ##########
      console.table(valid_questions)

      var [formattedData, type, categories] = aggregate_data(valid_questions, grouping = "rhythm")
      var stack = d3.stack()
        .keys(categories)
        .order(d3.stackOrderNone)
        .offset(d3.stackOffsetNone);

      var series = stack(formattedData);
      // add text
      d3.select("body").append("h2").html("Evaluation").style("margin-top", "30px")
      d3.select("body").append("div").attr("class", "tooltip")
      var tooltip = d3.select(".tooltip");
      d3.select("body").append("p").html("Here's your score: You have " + done_points + " of " + max_num_points +
      " I-do-it points and " + I_remembered_points + " of " + max_num_points + " I-remember-to-do-it points. " +
      "<br> This means you carry " + Math.round(100*(done_points/max_num_points)) + "% of the phyiscal labour and " +
      + Math.round(100*(I_remembered_points/max_num_points)) + "% of the mental labour."
      // "<br> <b> Your total score is " + (I_remembered_points + done_points) + "</b>."
      )
      d3.select("body").append("p").html("Keep in mind that your partner has probably a different view on the division of the tasks. " +
       "<b> This is only a reflection of your perspective!</b> " +
       "For a better comparison, your partner should also do the test to see where you might disagree on. ")
      // build_overview_chart()
      build_overview_percentage_chart()
      d3.select("body").append("h3").html("How does the scoring work?")
      d3.select("body").append("p").html("The tasks listed are weighted according to the frequency with which they need to be performed. " + 
          "Four points are awarded for tasks to be performed daily or more frequently. For weekly tasks, three points are awarded. " + 
          "For monthly tasks, two points are awarded. For annual tasks, one point is awarded. " + 
          "The subdivision into “Do I” and “Remember I” is done in order to map the mental load, i.e. the cognitive care work that takes place in the head, as well." +
          "<br> <b> This is explained using your do-it checkmarks that you have set in the test: </b>")
      build_explain_weights_chart()
      build_stacked_chart(series, type)
      d3.select("body").append("h3").html("Task comparisons")
      d3.select("body").append("p").html("To better understand your scores and see in which areas you could be more helpful " + 
          "(or to see, which are your strongsuit), you can compare your points according to their different attributes.")
      
      build_bar_comparison_charts(grouping = "rhythm")
      build_categories_diverging()
      d3.select("body").append("h3").html("Comparison to partner")
      d3.select("body").append("p").html("For this comparison we assume that your partner does all the tasks that you don't do. " +
       "And that they remember all the tasks you don't remember. " +
       "But we know that in everyday life, this might not be the case. Some tasks might be left behind and be a source of stress." +
       "<br> For this visualisation, each task is one circle and can be uniquely assigned to one of the four states: " +
       "<br> I do it and I also remember to do it; I do it but my partner reminds me to do it; my partner does it but I remind them to do it; partner both does it and remembers to do it. " +
       "<br> <b> Hover over the circles to see which task it is. </b> "
      )
      d3.select("body").append("p").html("Keep in mind that your partner has probably a different view on the division of the tasks. " +
       "<b> This is only a reflection of your perspective!</b> " +
       "For a better comparison, your partner should also do the test to see where you might disagree on. ")
      build_confusion_matrix()
      d3.select("body").append("h3").html("And now?")
      d3.select("body").append("p").html(
      "<br> If you and your partner find yourself in a traditional role distribution but would ideally want to have a more egalitarian " +
      "division of household chores and mental load: You are not alone. " +
      "Studies show that couples commonly  justify their own household practices with the strive for efficiency ('it's faster when I do it'), " + 
      "individual characteristics of the partners ('I'm just a bit more chaotic and laid back') and circumstances beyond their control " +
      "('my partner's work is just not as flexible so I pick up the children from childcare'). See Daminger (2020). ")
      "It is not only your individual result, but also that of political and societal structures and role models that have existed for centuries." +
      d3.select("body").append("p").html("So try looking less for culprits but rather look ahead. " +
      "<br> Do all of your divisions need to serve efficiency? Maybe there is a division that is not even that efficient (e.g. double checking with your partner " +
      "before entering something in the family calender because they are its sole master). " +
      "<br> Question the personality traits you assign to yourself and your partner. Maybe the 'chaotic' partner is a project manager in their day job. " +
      "Are those traits really innate qualities rather than learned skills? " +
      "And acknowledge that many decisions formed today's situation (choice of job, distance to school) and are not set in stone. "
      // "<br> But remember: An individual solution that fit your circumstances that both of you are happy with." +
      // "<br> and 'How Egalitarian Couples Make Sense of Non-egalitarian Household Practices' by A. Daminger (2020)" +
      // "<br> see affordance theory by McClelland & Sliwa (2023)"
      )
      d3.select("body").append("p").html("A redistribution takes effort for both parties in the relationship!" + 
        "<br> It might make sense to assign both the mental and physical load of one task to one person. You can find a minimum standard of completion both partners are happy with. " +
        "Important: Once assigned, this person has to take on the sole responsibility for that task! They can delegate or ask for help, but they will carry the mental load. " +
        "This means that the other person should (in the beginning) not issue reminders or ask about the progress of specific tasks. "
      )

      d3.select("body").append("h3").html("Redistribution tool")
      build_restructuring()
      // d3.select("body").append("h3").html("But what about the paid work?")
      // build_working_time()
      // d3.select("body").append("h2").html("Redistribution of Mental Load")

      // d3.select("body").append("h3").html("Social Role Theory")
      // d3.select("body").append("p").html("The unequal division of mental load is a product of social, political and economical circumstances. " + 
      // "The Social Role Theory, developed by Alice Eagly and Wendy Wood tries to explain the unequal division of labour " + 
      // "as well as the differences in affect and behaviour of men and women." + 
      // "<br> This infographic applies the theory to mental labour, have fun exploring!"
      // )
      // d3.select("body").append("img")
      // .attr("src", "/images/political_combined.png")
      // .attr("alt", "Social Role Theory and the Unequal division of Mental Labour")
      // .style("width", "850px")

      d3.select("body").append("div").style("height", "50px").attr("class", "spacing")

      // build_multiples_chart(grouping =  "rhythm")
      // build_categories_chart()

      //TODO: number of adults sharing responsibility in the household

      // build_bar_comparison_charts(grouping = "domain")
      //#endregion



      //#region             ##### build charts functions #####

      function build_overview_chart() {
        d3.select("body").append("div").attr("class", "overview_chart")

        // svg for plotting 
        var svg = d3.select(".overview_chart")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")")

        // X axis
        var x = d3.scaleBand()
          .range([0, width])
          .domain(types)
          .padding(0.2);


        // Add Y axis
        //initial with max number of points for daily tasks
        var y = d3.scaleLinear()
          .domain([0, 1.1 * max_num_points])
          .range([height, 0]);
        var yAxis = svg.append("g")
          .attr("class", "myYaxis")
          .call(d3.axisLeft(y));

        //yAxis label
        svg.append("text")
          .attr("class", "y axislabel")
          .attr("text-anchor", "end")
          .attr("y", -20)
          .attr("dy", ".75em")
          //.attr("transform", "translate(-40," + height/2 + "),rotate(-90)")
          .text("points");

        let rolled_up_I_do_it = d3.rollup(valid_questions, v => d3.sum(v, d => d.points), d => d.I_do_it)
        let rolled_up_I_remember = d3.rollup(valid_questions, v => d3.sum(v, d => d.points), d => d.I_remember)
        let data_overview = [
          { "type": "I_do_it", "value": rolled_up_I_do_it.get(true) },
          { "type": "I_remember", "value": rolled_up_I_remember.get(true) },
        ];
        //console.log(data_overview)

        svg.append("g").attr("class", "bars")
          .selectAll("rect")
          .data(data_overview)
          .enter().append("rect")
          //.text(function (d) { console.log(d.type); })
          .attr("x", function (d) { return x(d.type); })
          .attr("y", function (d) { return y(d.value); })
          //.text(function(d) {console.log(d.type);})
          .attr("width", x.bandwidth())
          .attr("height", function (d) { return height - y(d.value); })
          .attr("fill", mntlld_lightblue)
          .on("mouseover", function (event, d) {
            tooltip.style("visibility", "visible").text(d.value + " Points");
            d3.select(this).attr("fill", mntlld_red)
          })
          .on("mousemove", function (event, d) {
            tooltip.style("top", (event.pageY - 10) + "px")
              .style("left", (event.pageX + 10) + "px");
          })
          .on("mouseout", function (event, d) {
            d3.select(this).attr("fill", mntlld_lightblue);
            tooltip.style("visibility", "hidden");
          });

       
        //add 50% line
        svg.selectAll(".dashed_line")
          .data([max_num_points / 2, max_num_points])
          .enter()
          .append("line")
          .attr("class", "dashed_line")
          .attr("x1", 0)
          .attr("x2", width)
          .attr("y1", d => y(d))
          .attr("y2", d => y(d));

        //line labels
        svg.append("g").attr("class", "line_labels")
          .selectAll("label")
          .data([
            { "value": max_num_points / 2, "text": "50% of reachable points" },
            { "value": max_num_points, "text": "reachable points: " + max_num_points }
          ])
          .enter()
          .append("text")
          .attr("class", "label")
          .attr("x", width)
          .attr("y", d => y(d.value))
          .attr("dy", "-.35em")
          .style("text-anchor", "end")
          .text(d => d.text)

         //add bar labels
         svg.append("g").attr("class", "label")
          .selectAll("text.sum")
          .data([{ "sum": done_points, "type": "I_do_it" }, { "sum": I_remembered_points, "type": "I_remember" }])
          .enter()
          .append("text")
          .attr("class", "sum")
          //.text(function(d) {console.log(d)})
          .attr("x", (d) => x(d.type) + x.bandwidth() / 2)
          .attr("y", (d) => y(d.sum))
          .attr("dy", "-1em")
          .style("text-anchor", "middle")
          .text(d => d.sum);

        
        //x-Axis on top
          svg.append("g")
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x))
      }

      function build_overview_percentage_chart() {
        d3.select("body").append("div").attr("class", "overview_perc_chart")

        // svg for plotting 
        var svg = d3.select(".overview_perc_chart")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")")

        // X axis
        var x = d3.scaleBand()
          .range([0, width])
          .domain(types)
          .padding(0.2);


        // Add Y axis
        //initial with max number of points for daily tasks
        var y = d3.scaleLinear()
          .domain([0, 100])
          .range([height, 0]);
        var yAxis = svg.append("g")
          .attr("class", "myYaxis")
          .call(d3.axisLeft(y)
          .tickFormat(d => (Math.abs(d) + "%")))

        //yAxis label
        svg.append("text")
          .attr("class", "y axislabel")
          .attr("text-anchor", "middle")
          .attr("y", -30)
          .attr("dy", ".75em")
          // .attr("transform", "translate(-40," + 0 + "),rotate(-90)")
          .text("share of points");

        let rolled_up_I_do_it = d3.rollup(valid_questions, v => d3.sum(v, d => d.points), d => d.I_do_it)
        let rolled_up_I_remember = d3.rollup(valid_questions, v => d3.sum(v, d => d.points), d => d.I_remember)
        let data_overview = [
          { "type": "I_do_it", "value": 100 * (rolled_up_I_do_it.get(true)  / max_num_points) },
          { "type": "I_remember", "value": 100 * (rolled_up_I_remember.get(true)  / max_num_points)},
        ];
        //console.log(data_overview)

        svg.append("g").attr("class", "bars")
          .selectAll("rect")
          .data(data_overview)
          .enter().append("rect")
          //.text(function (d) { console.log(d.type); })
          .attr("x", function (d) { return x(d.type); })
          .attr("y", function (d) { return y(d.value); })
          // .text(function(d) {return (Math.round(10*d.value)/10) + " %"})
          .attr("width", x.bandwidth())
          .attr("height", function (d) { return height - y(d.value); })
          .attr("fill", mntlld_lightblue)
          .on("mouseover", function (event, d) {
            tooltip
              .style("visibility", "visible")
              .text(Math.round(d.value) + "%");
            d3.select(this).attr("fill", mntlld_red)
          })
          .on("mousemove", function (event, d) {
            tooltip.style("top", (event.pageY - 10) + "px")
              .style("left", (event.pageX + 10) + "px");
          })
          .on("mouseout", function (event, d) {
            d3.select(this).attr("fill", mntlld_lightblue);
            tooltip.style("visibility", "hidden");
          });

       
        //add 50% line
        svg.selectAll(".dashed_line")
          .data([50])
          .enter()
          .append("line")
          .attr("class", "dashed_line")
          .attr("x1", 0)
          .attr("x2", width)
          .attr("y1", d => y(d))
          .attr("y2", d => y(d));

        //line labels
        svg.append("g").attr("class", "line_labels")
          .selectAll("label")
          .data([
            { "value": 50, "text": "50% of reachable points" },
            // { "value": 100, "text": "reachable points: " + max_num_points }
          ])
          .enter()
          .append("text")
          .attr("class", "label")
          .attr("x", width)
          .attr("y", d => y(d.value))
          .attr("dy", "-.35em")
          .style("text-anchor", "end")
          .text(d => d.text)

         //add bar labels
         svg.append("g").attr("class", "label")
          .selectAll("text.sum")
          .data(data_overview)
          // .data([{ "sum": done_points, "type": "I_do_it" }, { "sum": I_remembered_points, "type": "I_remember" }])
          .enter()
          .append("text")
          .attr("class", "sum")
          //.text(function(d) {console.log(d)})
          .attr("x", (d) => x(d.type) + x.bandwidth() / 2)
          .attr("y", (d) => y(d.value))
          .attr("dy", "-1em")
          .style("text-anchor", "middle")
          .text(d => Math.round(d.value) + "%");

        
        //x-Axis on top
          svg.append("g")
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x))
      }


      function build_explain_weights_chart() {
        d3.select("body").append("div").attr("class", "explain_weights")
        
        
        var svg3 = d3.select(".explain_weights")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .attr("class", "explain_svg")
          .attr("position", "absolute")
          .append("g")
          .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")")

        var x_explain = d3.scaleBand()
          .range([0, width])
          .domain(["I-do-it checkmarks", "I-do-it points"])
          .paddingInner(0.5)
          .paddingOuter(0.5)


        var xAxis_explain = svg3.append("g")
          //.attr("transform", "translate(0,)")
          .call(d3.axisTop(x_explain))
        xAxis_explain.selectAll("path")
          .style("stroke", "none");

        var y_explain = d3.scaleLinear()
          .domain([done_points, 0])
          .range([height, 0]);
        svg3.append("g")
          .attr("transform", "translate(" + (width - 0.8 * x_explain.paddingOuter() * x_explain.step()) + ",0)")
          .call(d3.axisRight(y_explain));

        //aggregate according to points
        var [formattedData, type, categories] = aggregate_data(valid_questions, grouping = "rhythm")


        var stack = d3.stack()
          .keys(categories)
          .order(d3.stackOrderReverse)
          .offset(d3.stackOffsetNone);

        // aggregate by number of checkmarks
        var ticks_by_rhythm = d3.rollup(done_questions, v => v.length, d => d.rhythm)
        let formatted_ticks = {};
        let done_ticks = 0;
        rhythms.forEach(rhythm => {
          formatted_ticks[rhythm] = ticks_by_rhythm.get(rhythm) || 0;
          done_ticks += ticks_by_rhythm.get(rhythm) || 0
        });
        //console.log(done_ticks)
        //join checkmarks and points
        formattedData[1] = formatted_ticks
        var series = stack(formattedData) //stack data
        series.forEach(item => {
          item[0].data["type"] = "I-do-it points"
          item[1].data["type"] = "I-do-it checkmarks"
        })

        // data for lines
        var connection_lines = []
        series.forEach((item, index) => {
          connection_lines[index] = [item[1][1], item[0][1]]
        })
        var fraction_lines = []
        let i = 0;
        series.forEach((item, index) => {
          switch (item.key) {
            case rhythms[3]: //yearly
              // fraction_lines[i] = item[0][1]
              // i++;
              break;
            case rhythms[2]: //monthly
              // fraction_lines[i] = item[0][1]
              fraction_lines[i] = item[0][0] + (item[1][1] - item[1][0])
              i += 1;
              break;
            case rhythms[1]: //weekly
              // fraction_lines[i] = item[0][1]
              fraction_lines[i] = item[0][0] + (item[1][1] - item[1][0])
              fraction_lines[i + 1] = item[0][0] + 2 * (item[1][1] - item[1][0])
              i += 2;
              break;
            case rhythms[0]: //daily
              // fraction_lines[i] = item[0][1]
              fraction_lines[i] = item[0][0] + (item[1][1] - item[1][0])
              fraction_lines[i + 1] = item[0][0] + 2 * (item[1][1] - item[1][0])
              fraction_lines[i + 2] = item[0][0] + 3 * (item[1][1] - item[1][0])
              i += 3;
              break;
            default:
              break;
          }
          //fraction_lines[i]=[item[1][1], item[0][1]]

        })

        //rectangles
        svg3.append("g").attr("class", "rectangles")
          .selectAll("g")
          .data(series)
          .enter().append("g")
          .attr("class", d => "rects_" + d.key)
          .each(function(parentData) {
            d3.select(this)
            .selectAll("rect")
            .data(d => d)
            .enter().append("rect")
            .attr("fill", d => color(parentData.key))
            .attr("x", d => x_explain(d.data.type))
            .attr("y", d => y_explain(d[0]))
            .attr("height", d => y_explain(d[1]) - y_explain(d[0]))
            //.text(function(d) {console.log(parentData)})
            .attr("width", x_explain.bandwidth())
              .on("mouseover", function (event, d) {
                tooltip.style("visibility", "visible").text(
                  d.data.type == "I-do-it checkmarks" ? (d[1] - d[0]) + " checkmarks" : (d[1] - d[0]) + " points");
                d3.select(this)
                  .attr("fill", mntlld_red)
              })
              .on("mousemove", function (event, d) {
                tooltip.style("top", (event.pageY - 10) + "px")
                  .style("left", (event.pageX + 10) + "px");
              })
              .on("mouseout", function (event, d) {
                tooltip.style("visibility", "hidden");
                d3.select(this)
                  .attr("fill", color(parentData.key));
              })
          });

        //lines
        svg3
          .append("g").attr("class", "connection_lines")
          .selectAll("line.connection_line")
          .data(connection_lines)
          .enter()
          .append("line")
          .attr("class", "connection_line")
          //.text(function(d) {console.log(d)})
          .style("stroke", "black")
          .attr("x1", x_explain.paddingOuter() * x_explain.step() + x_explain.bandwidth())
          .attr("x2", x_explain.paddingOuter() * x_explain.step() + x_explain.bandwidth() + x_explain.paddingInner() * x_explain.step())
          .attr("y1", (d) => y_explain(d[0]))
          .attr("y2", (d) => y_explain(d[1]));

        svg3.append("g").attr("class", "fraction_lines")
          .selectAll("line.fraction_line")
          .data(fraction_lines)
          .enter()
          .append("line")
          .attr("class", "dashed_line")
          //.text(function(d) {console.log(d)})
          // .style("stroke", "black")
          // .style("stroke-dasharray", ("4, 4"))
          // .style("stroke-width", 0.5)
          // .attr("x1", x_explain.paddingOuter()*x_explain.step() + x_explain.bandwidth() + x_explain.paddingInner()*x_explain.step())
          // .attr("x2", x_explain.paddingOuter()*x_explain.step() + 2*x_explain.bandwidth() + x_explain.paddingInner()*x_explain.step())
          .attr("x1", x_explain.paddingOuter() * x_explain.step() + x_explain.bandwidth() + x_explain.bandwidth())
          .attr("x2", x_explain.paddingOuter() * x_explain.step() + 2 * x_explain.bandwidth() + x_explain.paddingInner() * x_explain.step())
          .attr("y1", (d) => y_explain(d))
          .attr("y2", (d) => y_explain(d));

        svg3.append("g").attr("class", "annotation")
          .selectAll("text.multiplier")
          .data(series)
          .enter()
          .append("text")
          .attr("class", "multiplier")
          .attr("x", width / 2)
          .attr("y", (d) => y_explain(((d[1][0] + (d[1][1] - d[1][0]) / 2) + (d[0][0] + (d[0][1] - d[0][0]) / 2)) / 2))
          .attr("dy", ".35em")
          .style("text-anchor", "middle")
          .html(d => "&times;" + (d.index + 1));

        svg3.append("g").attr("class", "label")
          .selectAll("text.legend")
          .data(series)
          .enter()
          .append("text")
          .attr("class", "legend")
          //.text(function(d) {console.log(d)})
          .attr("x", x_explain.paddingOuter() * x_explain.step())
          .attr("y", (d) => y_explain(d[1][0] + (d[1][1] - d[1][0]) / 2))
          .attr("dx", "-.35em")
          .attr("dy", ".35em")
          .style("text-anchor", "end")
          .text(d => d.key);

        svg3.append("g").attr("class", "label")
          .selectAll("text.sum")
          .data([{ "sum": done_points, "type": "I-do-it points" }, { "sum": done_ticks, "type": "I-do-it checkmarks" }])
          .enter()
          .append("text")
          .attr("class", "sum")
          //.text(function(d) {console.log(d)})
          .attr("x", (d) => x_explain(d.type) + x_explain.bandwidth() / 2)
          .attr("y", (d) => y_explain(d.sum))
          .attr("dy", "1.2em")
          .style("text-anchor", "middle")
          .text(d => d.sum);
      }


      function build_confusion_matrix() {
        d3.select("body").append("div").attr("class", "confusion_matrix")
    

        var conf_margin = { top: 30, right: 400, bottom: 20, left: 20 };
        var conf_width = 1200 - conf_margin.left - conf_margin.right;
        var conf_height = 400 - conf_margin.top - conf_margin.bottom;


        const innerWidth = conf_width - conf_margin.left - conf_margin.right;
        const innerHeight = conf_height - conf_margin.top - conf_margin.bottom;

        const x_confusion = d3.scaleBand()
          .domain(['I_remember', 'partner_remembers'])
          .range([0, innerWidth]);

        const y_confusion = d3.scaleBand()
          .domain(['I_do_it', 'partner_does_it'])
          .range([0, innerHeight]);

        const svg_confusion = d3.select(".confusion_matrix")
          .append("svg")
          .attr("width", conf_width)
          .attr("height", conf_height)
          .append("g")
          .attr("transform", `translate(${conf_margin.left},${conf_margin.top})`);

        // Add column labels
        svg_confusion.selectAll(".column-label")
          .data(x_confusion.domain())
          .enter().append("text")
          .attr("class", "column-label")
          .attr("x", d => x_confusion(d) + x_confusion.bandwidth() / 2)
          .attr("y", -10) // Position above the grid
          .attr("text-anchor", "middle")
          .text(d => d);

        // Add row labels
        svg_confusion.selectAll(".row-label")
          .data(y_confusion.domain())
          .enter().append("text")
          .attr("class", "row-label")
          .attr('transform', d => 'translate(' + -10 + ',' + (y_confusion(d) + y_confusion.bandwidth() / 2) + '),' + 'rotate(-90)')
          //.text(function(d) {console.log(y_confusion.bandwidth() / 2)})
          .attr("text-anchor", "middle")
          .attr("dy", "0.35em") // Vertical alignment
          .text(d => d);

        // calculate radius based on points
        const radiusScale = d3.scaleSqrt()
          .domain([0, d3.max(valid_questions, d => d.points)])
          .range([0, 10]);

        // Map data to cell positions
        const mappedData = valid_questions.map(d => ({
          ...d,
          x: x_confusion(d.I_remember ? "I_remember" : "partner_remembers") + x_confusion.bandwidth() / 2,
          y: y_confusion(d.I_do_it ? "I_do_it" : "partner_does_it") + y_confusion.bandwidth() / 2,
          r: radiusScale(d.points)
        }));

        // Create simulation
        const simulation = d3.forceSimulation(mappedData)
          .force("x", d3.forceX(d => d.x).strength(1))
          .force("y", d3.forceY(d => d.y).strength(1))
          .force("collide", d3.forceCollide(d => d.r))
          .stop();

        for (let i = 0; i < 500; ++i) simulation.tick(); // Run the simulation
        // Draw points
        svg_confusion.append("g").selectAll(".point")
          .data(mappedData)
          .enter().append("circle")
          .attr("class", "point")
          .attr("cx", d => d.x)
          .attr("cy", d => d.y)
          .attr("r", d => d.r)
          .attr("fill", d => domainColor(d.domain))
          .on("mouseover", function (event, d) {
            tooltip.style("visibility", "visible").text(d.Text);
            d3.select(this).attr("fill", mntlld_dark_grey)
          })
          .on("mousemove", function (event, d) {
            tooltip.style("top", (event.pageY - 10) + "px")
              .style("left", (event.pageX + 10) + "px");
          })
          .on("mouseout", function (event, d) {
            d3.select(this).attr("fill", domainColor(d.domain));
            tooltip.style("visibility", "hidden");
          });


        // legend
        const legend = svg_confusion.append("g")
          .attr("class", "legend")
          .attr("transform", `translate(${innerWidth + 40}, 20)`);

        // Add size legend
        const sizeLegend = legend.append("g")
          .attr("class", "size-legend");

        sizeLegend.append("text")
          .attr("x", 0)
          .attr("y", 0)
          .text("Size (Frequency):")
          .style("font-size", "16px")
          .style("font-weight", 500);

        const sizeValues = [...new Set(valid_questions.map(d => d.points))];

        sizeLegend.selectAll("circle")
          .data(sizeValues)
          .enter().append("circle")
          .attr("cx", 10)
          .attr("cy", (d, i) => 21 + i * 25)
          .attr("r", d => radiusScale(d))
          .attr("fill", mntlld_dark_grey)
          //.attr("stroke", "darkgrey");

        sizeLegend.selectAll("text.size-label")
          .data(sizeValues)
          .enter().append("text")
          .attr("class", "size-label")
          .attr("x", 30)
          .attr("y", (d, i) => 20 + i * 25)
          .attr("dy", "0.35em")
          .style("font-size", "14px")
          .text(d => rhythms[Math.abs(d - 4)]);

        // Add color legend
        const colorLegend = legend.append("g")
          .attr("class", "color-legend")
          .attr("transform", "translate(0, 150)");

        colorLegend.append("text")
          .attr("x", 0)
          .attr("y", 0)
          .style("font-size", "16px")
          .style("font-weight", 500)
          .text("Colour (Domain):");

        const domainValues = [...new Set(valid_questions.map(d => d.domain))];

        colorLegend.selectAll("rect")
          .data(domainValues)
          .enter().append("rect")
          .attr("x", 10)
          .attr("y", (d, i) => 20 + i * 20)
          .attr("width", 10)
          .attr("height", 10)
          .attr("fill", d => domainColor(d));

        colorLegend.selectAll("text.color-label")
          .data(domainValues)
          .enter().append("text")
          .attr("class", "color-label")
          .attr("x", 30)
          .attr("y", (d, i) => 25 + i * 20) // Adjust y to vertically center with the rect
          .attr("dy", "0.35em")
          .text(d => d)
          .style("font-size", "14px");

      }


      function build_stacked_chart(series, type) {

        let svg = d3.select(".explain_weights")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .attr("transform",
            "translate(" + margin.left + ",0)")
          .attr("class", "stacked_svg")
          .append("g")
          .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")")

        // X axis
        let x = d3.scaleBand()
          .range([0, width])
          .domain(type)
          .padding(0.2);

        // Add Y axis
        let y = d3.scaleLinear()
          .domain([0, Math.max(done_points, I_remembered_points) + 20])
          .range([height, 0]);
        svg.append("g")
          .attr("class", "myYaxis")
          .call(d3.axisLeft(y));

        svg.append("text")
          .attr("class", "y axislabel")
          .attr("text-anchor", "end")
          .attr("y", -20)
          .attr("dy", ".75em")
          //.attr("transform", "translate(-40," + height/2 + "),rotate(-90)")
          .text("points");


        svg.append("g")
          .selectAll("g")
          // Enter in the stack data = loop key per key = group per group
          .data(series)
          .enter().append("g")
          .attr("class", d => "rects_" + d.key)
          .each(function(parentData) {
            d3.select(this)
            .selectAll("rect")
            .data(d => d)
            .enter().append("rect")
            .attr("fill", d => color(parentData.key))
            .attr("class", "serie")
            .attr("x", d => x(d.data.type))
            .attr("y", d => y(d[1]))
            // .text(function(d) {console.log(x(d.data.type))})
            .attr("height", d => y(d[0]) - y(d[1]))
            .attr("width", x.bandwidth())
            .on("mouseover", function (event, d) {
                tooltip.style("visibility", "visible").text((d[1] - d[0]) + " points");
                d3.select(this)
                  .attr("fill", mntlld_red)
              })
              .on("mousemove", function (event, d) {
                tooltip.style("top", (event.pageY - 10) + "px")
                  .style("left", (event.pageX + 10) + "px");
              })
              .on("mouseout", function (event, d) {
                tooltip.style("visibility", "hidden");
                d3.select(this)
                  .attr("fill", color(parentData.key));
              });
            });

        svg.append("g").attr("class", "label")
          .selectAll("text.sum")
          .data([{ "sum": done_points, "type": "I_do_it" }, { "sum": I_remembered_points, "type": "I_remember" }])
          .enter()
          .append("text")
          .attr("class", "sum")
          //.text(function(d) {console.log(d)})
          .attr("x", (d) => x(d.type) + x.bandwidth() / 2)
          .attr("y", (d) => y(d.sum))
          .attr("dy", "-1em")
          .style("text-anchor", "middle")
          .text(d => d.sum);

        //title
        svg
          .append("text")
          .attr("class", "chart_title")
          .attr("x", (width / 2))
          .attr("y", -30)
          .attr("text-anchor", "middle")
          .text("composition of points");
      
        // append x-axis on top
        svg.append("g")
          .attr("class", "xAxis")
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x));

        // legend

        let legend = svg.append("g")
          .attr("class", "legend")
          .attr("transform", `translate( ${width - 18} , 0)`);

        legend.append("g").attr("class", "legend_rectangles")
          .selectAll("rect")
          .data(rhythms.slice().reverse())
          .enter().append("rect")
          .attr("transform", (d, i) => `translate(0, ${i * 20})`)
          .attr("width", 18)
          .attr("height", 18)
          .style("fill", color);


        legend.append("g").attr("class", "legend_text")
          .selectAll("text")
          .data(rhythms.slice().reverse())
          .enter().append("text")
          .attr("transform", (d, i) => `translate(-5, ${i * 20 + 9})`)
          .attr("dy", ".35em")
          .style("text-anchor", "end")
          .style("font-size", "80%")
          .text(d => d)

      }


      function build_multiples_chart(grouping) {

        //prep data
        let grouped_data = d3.group(valid_questions, d => d[grouping], d => d.I_remember)
        let grouped_I_do_it_data = d3.group(valid_questions, d => d[grouping], d => d.I_do_it)
        //console.log(grouped_I_do_it_data)
        //console.table(group_test.get("täglich"))
        let I_do_it_points = []
        let I_remember_points = []

        grouped_data.forEach(function (value, key) {
          value.delete(false)
          let to_rename = value.get(true)
          if (!to_rename) { to_rename = [{ "points": 0 }] }
          value.set("I_remember", to_rename)
          value.delete(true)
          let I_do_it = grouped_I_do_it_data.get(key)
          if (!I_do_it) { I_do_it = [{ "points": 0 }] }
          value.set("I_do_it", I_do_it.get(true))
          I_do_it_points.push(d3.sum(value.get("I_do_it"), (d) => d.points))
          I_remember_points.push(d3.sum(value.get("I_remember"), (d) => d.points))

        })
        // console.log(grouped_data)

        // create svg
        var small_multiples_width = width / 2
        d3.select("body").append("div").attr("class", grouping + "_small_multiples")
        var svg_multiples = d3.select("." + grouping + "_small_multiples")
          .append("g")
          .selectAll("g")
          .data(grouped_data)
          .enter()
          .append("svg")
          .attr("class", "small_multiples_svg")
          .attr("width", small_multiples_width + margin.left + margin.right)
          .attr("height", small_multiples_width + margin.top + margin.bottom)
          // .text(function(d) {console.log(remove_weird_symbols(d[0]))})
          //.text(function(d) {console.log(d);})
          .append("g")
          .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")")
          .attr("class", function (d) { return remove_weird_symbols(d[0]); })

        // X axis
        var x_multiples = d3.scaleBand()
          .range([0, small_multiples_width])
          .domain(types)
          .padding(0.1);
        


        // Add Y axis
        var y_multiples = d3.scaleLinear()
          // .domain([0, Math.max(...I_do_it_points.concat(I_remember_points, max_reachable_points_per_rhythm))+20]) 
          .domain([0, 100])
          .range([small_multiples_width, 0]);
        svg_multiples.append("g")
          .attr("class", "myYaxis_multiples")
          .call(d3.axisLeft(y_multiples));
        let grouped_by_grouping = d3.group(valid_questions, d => d[grouping])

        grouped_data.forEach(function (data, i) {
          let max_points = d3.sum(grouped_by_grouping.get(i), (d) => d.points)
          let classname = remove_weird_symbols(i);
          d3.select("g." + classname)
            .selectAll('.bar')
            .data(data)
            .enter()
            .append("rect")
            //.text(function(d) {console.log(d)})
            .attr("x", function (d) { return x_multiples(d[0]); })
            .attr("y", function (d) { return y_multiples(100*(d3.sum(d[1], (s) => s.points)) / max_points) })
            // .text(function(d) {
            //    console.log((d3.sum(d[1], (s) => s.points)/max_points));
            //   d3.sum(I_remembered_questions, (d) => d.points)
            //                   //  console.log(d)
            //  })
            .attr("width", x_multiples.bandwidth())
            .attr("height", function (d) { return small_multiples_width - y_multiples(100*(d3.sum(d[1], (s) => s.points)) / max_points); })
            .attr("fill", function (d) { return grouping == "domain" ? domainColor(i) : color(i) });

          //console.log(max_points)

          d3.select("g." + classname)
            .append("line")
            .attr("class", "dashed_line")
            //.text(function(d) {console.log(d)})
            // .style("stroke", "grey")
            .attr("x1", 0)
            .attr("x2", small_multiples_width)
            .attr("y1", (d) => y_multiples(50))
            .attr("y2", (d) => y_multiples(50));



          //title
          d3.select("g." + classname)
            .append("text")
            .attr("class", "chart_title")
            .attr("x", (small_multiples_width / 2))
            .attr("y", 0 - (margin.top / 3))
            .attr("text-anchor", "middle")
            .text(i);

          d3.select("g." + classname).append("text")
            .attr("x", small_multiples_width)
            .attr("y", (d) => y_multiples(50))
            .attr("dy", "-.35em")
            .attr("text-anchor", "end")
            .style("font-size", "80%")
            .text("50%")

        })

        svg_multiples.append("g")
          .attr("transform", "translate(0," + small_multiples_width + ")")
          .call(d3.axisBottom(x_multiples))
      }

      function build_bar_comparison_charts(grouping) {
        d3.select("body").append("div").attr("class", grouping + "_bar_comp")
        d3.select("." + grouping + "_bar_comp").append("h4").html("By frequency of tasks")

        let margin = { top: 50, right: 20, bottom: 40, left: 60 };
        let width = 400 - margin.left - margin.right;
        let height = 250 - margin.top - margin.bottom;
        
        //prep data
        let grouped_data_I_remember = d3.rollup(valid_questions, v => d3.sum(v, d => d.points),  d => d.I_remember, d => d[grouping])
        let grouped_I_do_it_data = d3.rollup(valid_questions, v => d3.sum(v, d => d.points),  d => d.I_do_it, d => d[grouping])
        let grouped_data = new Map();
        grouped_data.set("I_do_it", normaliseMap(grouped_I_do_it_data));
        grouped_data.set("I_remember", normaliseMap(grouped_data_I_remember));
  

        // create svg
      
        
        let svg_multiples = d3.select("." + grouping + "_bar_comp")
          .append("g")
          .selectAll("g")
          .data(grouped_data)
          .enter()
          .append("svg")
          .attr("class", "small_multiples_svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")")
            .attr("class", function (d) { return (grouping + "_" + remove_weird_symbols(d[0])); })

        let x_axis_grouping;
        switch (grouping) {
          case "domain":
            x_axis_grouping = uniqueDomains
            break;
            case "rhythm":
            x_axis_grouping = rhythms
            break;
 
        }
        // X axis
        let x_multiples = d3.scaleBand()
          .range([0, width])
          .domain(x_axis_grouping)
          .padding(0.1);


        // Add Y axis
        let y_multiples = d3.scaleLinear()
          // .domain([0, Math.max(...I_do_it_points.concat(I_remember_points, max_reachable_points_per_rhythm))+20]) 
          .domain([0, 100])
          .range([height, 0]);
        svg_multiples.append("g")
          .attr("class", "myYaxis_multiples")
          .call(d3.axisLeft(y_multiples));
        

        grouped_data.forEach(function (data, i) {
          let classname = remove_weird_symbols(i);
          d3.select("g." + grouping + "_" +  classname)
            .selectAll('.bar')
            .data(data)
            .enter()
            .append("rect")
            //.text(function(d) {console.log(d)})
            .attr("x", function (d) { return x_multiples(d[0]); })
            .attr("y", function (d) { return y_multiples(d[1]); })
            .attr("width", x_multiples.bandwidth())
            .attr("height", function (d) { return height - y_multiples(d[1]); })
            .attr("fill", function (d) { return grouping == "domain" ? domainColor(d[0]) : color(d[0]) })
            .on("mouseover", function (event, d) {
                tooltip.style("visibility", "visible").text(d[1] + "%");
                d3.select(this)
                  .attr("fill", mntlld_red)
              })
              .on("mousemove", function (event, d) {
                tooltip.style("top", (event.pageY - 10) + "px")
                  .style("left", (event.pageX + 10) + "px");
              })
              .on("mouseout", function (event, d) {
                d3.select(this).attr("fill", function (d) { return grouping == "domain" ? domainColor(d[0]) : color(d[0]) });
                tooltip.style("visibility", "hidden");
              });

          //console.log(max_points)
          let g_of_grouping = d3.select("g." + grouping + "_" +  classname)
          
          //dashed line
          g_of_grouping
            .append("line")
            .attr("class", "dashed_line")
            //.text(function(d) {console.log(d)})
            .attr("x1", 0)
            .attr("x2", width)
            .attr("y1", (d) => y_multiples(50))
            .attr("y2", (d) => y_multiples(50));
          
          //line label
          g_of_grouping
            .append("text")
            .attr("class", "label")
            .attr("x", width)
            .attr("y", (d) => y_multiples(50))
            .attr("dy", "-.35em")
            .attr("text-anchor", "end")
            .text("50%")

          //title
          g_of_grouping
            .append("text")
            .attr("class", "chart_title")
            .attr("x", (width / 2))
            .attr("y", 0 - (margin.top / 3))
            .attr("text-anchor", "middle")
            .text(i);


          //yAxis label
          g_of_grouping.append("text")
            .attr("class", "y axislabel")
            .attr("text-anchor", "end")
            //.attr("y", -20)
            .attr("dy", ".75em")
            .attr("transform", "translate(-50," + 0 + "),rotate(-90)")
            .text("share of points, in %");

          })

          //x-Axis
          svg_multiples.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x_multiples))
      }
      
    // ####################################################################################################################
      function build_categories_chart() {
      d3.select("body").append("div").attr("class", "categories_chart")
      d3.select(".categories_chart").append("h4").html("By task categories")
        


        //prep data
        let grouped_data_I_remember = d3.rollup(valid_questions, v => d3.sum(v, d => d.points),  d => d.I_remember, d => d.domain, d => d.category)
        let grouped_I_do_it_data = d3.rollup(valid_questions, v => d3.sum(v, d => d.points),  d => d.I_do_it,  d => d.domain, d => d.category)
      
        let grouped_data = new Map();
        grouped_data.set("I_do_it", sortInnerMaps(normaliseMap(grouped_I_do_it_data)));
        grouped_data.set("I_remember", sortInnerMaps(normaliseMap(grouped_data_I_remember)));
        // get categories in correct order
        let categories_sorted_do_it = [];
        grouped_data.get("I_do_it").forEach(function(item) {
          for (let innerKey of item.keys()) {
            categories_sorted_do_it.push(innerKey)
          }
        })
        let categories_sorted_remember = [];
        grouped_data.get("I_remember").forEach(function(item) {
          for (let innerKey of item.keys()) {
            categories_sorted_remember.push(innerKey)
          }
        })
        //console.log(categories_sorted_remember)
        //d3.sort(grouped_data.get("I_do_it"), (d) => d.value)
        //console.log(d3.ascending(grouped_data.get("I_do_it").get("All care-communities, for example couples")))
        
        // create svg
        let margin = { top: 50, right: 20, bottom: 40, left: 250 };
        let width = 500 - margin.left - margin.right;
        let height = 400 - margin.top - margin.bottom;

        
        let svg_multiples = d3.select(".categories_chart")
          .append("g")
          .selectAll("g")
          .data(grouped_data)
            .enter()
            .append("svg")
            .attr("class", "small_multiples_svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            // .text(function(d) {console.log(remove_weird_symbols(d[0]))})
            //.text(function(d) {console.log(d[0]);})
            .append("g")
            .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")")
            .attr("class", function (d) { return remove_weird_symbols(d[0]); })
        

        // Add X axis
        let x = d3.scaleLinear()
          // .domain([0, Math.max(...I_do_it_points.concat(I_remember_points, max_reachable_points_per_rhythm))+20]) 
          .domain([0, 100])
          .range([ 0, width]);

        
        // Y axis
        // let fy = d3.scaleBand()
        //   .range([0, height])
        //   .domain(uniqueDomains)
        //   .padding(0.1);
        // console.log(fy.bandwidth())

        let y_do_it = d3.scaleBand()
          .range([0, height])
          .domain(categories_sorted_do_it)
          .padding(0.05);
        
        let y_remember = d3.scaleBand()
          .range([0, height])
          .domain(categories_sorted_remember)
          .padding(0.05);

        // svg_multiples.append("g")
        //   .attr("transform", "translate(0,0)")
        //   .call(d3.axisLeft(fy))



        grouped_data.forEach(function (data, i) {
          //console.log(data)
          let classname = remove_weird_symbols(i);
          

          let test = d3.select("g." + remove_weird_symbols(i))
            .selectAll('g.group')
            .data(data)
            .enter()
            .append("g")
            // .attr("transform", (d, i) => `translate(0,${5*i})`)
            .attr("class", "group")
            .attr("fill", function (d) { return domainColor(d[0]) })
            .selectAll('rect')
            .data(([,d]) => d)
            .enter()
              .append('rect')
              .attr("x", 0)
              .attr("y", function (d) { return i == "I_do_it" ?  y_do_it (d[0]) : y_remember(d[0]) })
            .attr("height", y_do_it.bandwidth())
            .attr("width", function (d) { return x(d[1]); })

          let g_of_grouping = d3.select("g." + remove_weird_symbols(i))
          
            //dashed line
          g_of_grouping
            .append("line")
            .attr("class", "dashed_line")
            //.text(function(d) {console.log(d)})
            .attr("y1", 0)
            .attr("y2", height)
            .attr("x1", (d) => x(50))
            .attr("x2", (d) => x(50));
          

          //title
          g_of_grouping
            .append("text")
            .attr("class", "chart_title")
            .attr("x", (width / 2))
            .attr("y", 0 - (margin.top / 3))
            .attr("text-anchor", "middle")
            .text(i);


          //yAxis label
          g_of_grouping.append("text")
            .attr("class", "y axislabel")
            .attr("text-anchor", "end")
            .attr("y", (height + 25))
            .attr("x", (width))
            .attr("dy", ".75em")
            //.attr("transform", "translate(-50," + 0 + "),rotate(-90)")
            .text("share of points, in %");

          switch (i) {
            case "I_do_it":
            g_of_grouping.append("g")
              .attr("transform", "translate(0,0)")
              .call(d3.axisLeft(y_do_it))
              break;

              case "I_remember":
              g_of_grouping.append("g")
              .attr("transform", "translate(0,0)")
              .call(d3.axisLeft(y_remember))
              break;
          
            default:
              break;
          }
        })

        //add x_axis

        svg_multiples.append("g")
          .attr("transform", "translate(0," + (height) + ")")
          .call(d3.axisBottom(x));
        


      }
      
      function build_categories_diverging() {
        d3.select("body").append("div").attr("class", "categories_diverging")
        d3.select(".categories_diverging").append("h4").html("By task categories")
        
        let margin = { top: 80, right: 400, bottom: 0, left: 230 };
        let width = 1000 - margin.left - margin.right;
        let height = 420 - margin.top - margin.bottom;
        
        //prep data
        let grouped_I_do_it_data = d3.rollup(valid_questions, v => d3.sum(v, d => (d.points * (-1))),  d => d.I_do_it, d=> d.domain, d => d.category)
        let grouped_data_I_remember = d3.rollup(valid_questions, v => d3.sum(v, d => d.points),  d => d.I_remember, d=> d.domain, d => d.category)
        //console.log(grouped_I_do_it_data)
        
        let grouped_data = new Map();
        grouped_data.set("I_do_it", normaliseAndSpecify(grouped_I_do_it_data));
        grouped_data.set("I_remember", normaliseAndSpecify(grouped_data_I_remember));
        // console.log(grouped_data)
        
        // create svg
        let svg_multiples = d3.select(".categories_diverging")
            .append("svg")
            .attr("class", "small_multiples_svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            // .text(function(d) {console.log(remove_weird_symbols(d[0]))})
            //.text(function(d) {console.log(d[0]);})
            .append("g")
            .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")")
            .attr("class", "group_diverging")

        

        // Add X axis scale
        let x = d3.scaleLinear()
          // .domain([0, Math.max(...I_do_it_points.concat(I_remember_points, max_reachable_points_per_rhythm))+20]) 
          .domain([-100, 100])
          .range([ 0, width]);


        let y = d3.scaleBand()
          .range([0, height])
          .domain(uniqueCategories)
          .padding(0.1);

          
          d3.select(".group_diverging")
            .selectAll("g")
            .data(grouped_data).enter()
              .append("g")
              .attr("class", d => "group_" + d[0])
              // .text(function(d) {console.log(d[0])}) //I do it and remember
              .selectAll("g")
              .data(([,d]) => d).enter()
                .append("g", d => "group_" + d[0]) //domains
                .attr("fill", function (d) { return domainColor(d[0]) })
                .selectAll('rect')
                .data(([,d]) => d).enter() //categories
                  .append('rect')
                    .attr("x", d => (x(d[1][0])))
                    .attr("y", d => y(d[0]) )
                    .attr("height", y.bandwidth())
                    .attr("width", d => ((x(Math.max(Math.abs(d[1][0]), Math.abs(d[1][1])))) - x(0)))
                    .on("mouseover", function (event, d) {
                      tooltip.style("visibility", "visible").text(Math.max(Math.abs(d[1][0]), Math.abs(d[1][1])) + "%");
                      d3.select(this)
                        .attr("fill-opacity", "0.7")
                    })
                    .on("mousemove", function (event, d) {
                      tooltip.style("top", (event.pageY - 10) + "px")
                        .style("left", (event.pageX + 10) + "px");
                    })
                    .on("mouseout", function (event, d) {
                      d3.select(this).attr("fill-opacity", "1");
                      tooltip.style("visibility", "hidden");
                    });
                    // .text(function(d) {console.log(d)})
                    // .text(function(d) {console.log(Math.abs((d[1][0])))})
                    //.text(function(d) {console.log(d[1])})
                  // .attr("fill", function (d) { return domainColor(i) });

        let g_of_grouping = d3.select("g.group_diverging")

        //add grid
        g_of_grouping
          .insert("g",":first-child") //behind the bars
          .attr("class", "grid")
          .attr("transform", `translate(0,${height})`)
          .call(d3.axisBottom(x)
                  .ticks(width / 50)
                  .tickSize(-height)
                  .tickFormat(""))
          .call(g => g.select(".domain").remove());
          
          //middle line
          g_of_grouping.append("g").attr("class", "lines")
            .selectAll(".zero_line")
            .data([
              {"width": 4, "col": "white"},
              {"width": 1, "col": "black"}])
            .join("line")
              .attr("class", "zero_line")
              .attr("stroke", d=>d.col)
              .attr("stroke-width", d=>d.width)
              .attr("y1", 0)
              .attr("y2", height)
              .attr("x1", (d) => x(0))
              .attr("x2", (d) => x(0));
            
            //dashed line
            g_of_grouping.select(".lines")
            .selectAll(".dashed_line")
            .data([-50, 50]).enter()
            .append("line")
            .attr("class", "dashed_line")
            .attr("stroke", "black")
            .attr("y1", 0)
            .attr("y2", height)
            .attr("x1", (d) => x(d))
            .attr("x2", (d) => x(d));
          
          // //line label
          // g_of_grouping
          //   .append("text")
          //   .attr("class", "label")
          //   .attr("x", height)
          //   .attr("x", (d) => x(50))
          //   .attr("dy", "-.35em")
          //   .attr("text-anchor", "end")
          //   .text("50%")

          //title
          g_of_grouping
            .append("text")
            .attr("class", "chart_title")
            .attr("x", (0))
            .attr("y", 0 - (margin.top))
            .attr("dy", "1em")
            .attr("text-anchor", "middle")
            .text("Share of points by category");


  
        //add x_axis
        svg_multiples.append("g")
            .attr("transform", `translate(0,${0})`)
          .call(d3.axisTop(x)
              .ticks(width / 50)
              .tickFormat(d => (Math.abs(d) + "%"))
              .tickSizeOuter(0))
          .call(g => g.select(".domain").remove())
          .call(g => g.append("text")
              .attr("class", "x axislabel")
              .attr("x", x(50))
              .attr("y", -28)
              .attr("fill", "currentColor")
              .attr("text-anchor", "middle")
              .style("font-size", "150%")
              .text("I remember"))
          .call(g => g.append("text")
              .attr("class", "x axislabel")
              .attr("x", x(-50))
              .attr("y", -28)
              .attr("fill", "currentColor")
              .attr("text-anchor", "middle")
              .style("font-size", "150%")
              .text("I do it"));
          
          //xAxis label
          g_of_grouping.append("text")
            .attr("class", "x axislabel")
            .attr("text-anchor", "end")
            .attr("y", (height + 15))
            .attr("x", (width))
            //.attr("transform", "translate(-50," + 0 + "),rotate(-90)")
            .text("share of points");
   
          
          // svg_multiples.append("g").attr("class", "y_axis")
          // .attr("transform", "translate(0,0)")
          // .call(d3.axisLeft(y))
          // .call(g => g.select(".domain").remove());
        
        //y-Axis
        g_of_grouping.append("g")
          .attr("transform", "translate(-10,0)")
          .call(d3.axisLeft(y)
            .tickSize(0))
          .call(g => g.select(".domain").remove())
          ;

        // legend
        const legend = svg_multiples.append("g")
          .attr("class", "legend")
          .attr("transform", `translate(${width + 40}, 20)`);


          legend.append("text")
          .attr("x", 0)
          .attr("y", 0)
          .style("font-size", "16px")
          .style("font-weight", 500)
          .text("Colour (Domain):");

          legend.selectAll("rect")
          .data(uniqueDomains)
          .enter().append("rect")
          .attr("x", 10)
          .attr("y", (d, i) => 20 + i * 20)
          .attr("width", 10)
          //.text(function(d) {console.log(d)})
          .attr("height", 10)
          .attr("fill", d => domainColor(d));

          legend.selectAll("text.color-label")
          .data(uniqueDomains)
          .enter().append("text")
          .attr("class", "color-label")
          .attr("x", 30)
          .attr("y", (d, i) => 25 + i * 20) 
          .attr("dy", "0.35em")
          .text(d => d)
          .style("font-size", "14px"); 

        


      }
      
      function build_working_time() {
        var total_percentage = 0.5; //start with 50/50 distribution
        let input_data = [
          {"text": "Person 1: Working hours per week", "value": 40, "id":"Person1"},
          {"text": "Hours children in childcare per day", "value": 8, "id":"Childcare"},
          {"text": "Person 2: Working hours per week", "value": 20, "id":"Person2"}
        ]

        var numbers = [];
        var sum = 0;

        
        let margin = { top: 50, right: 40, bottom: 40, left: 20 };
        let width = 400 - margin.left - margin.right;
        let height = 150 - margin.top - margin.bottom;
      
        // colours
        let work_colour = d3.scaleOrdinal()
          .domain(input_data.map(item => item.id))
          .range([mntlld_lightblue, mntlld_grey, mntlld_green])
        let work_division_colour_ids = ["Person1-PaidWork", "Person1-Childcare",
                                         "Person2-Childcare", "Person2-PaidWork"];
        let work_division_colour = d3.scaleOrdinal()
          .domain(work_division_colour_ids)
          .range([mntlld_lightblue, "#7EC2D6", "#B9D57A", mntlld_green])

        //start appending

        let div = d3.select("body").append("div").attr("class", "working_time").style("display", "block")
        div.append("p").style("display", "block")
          .html("Mental Load is difficult to measure in time since it's often in parallel of performing other tasks. "
           + "But we can take the example of childcare to visualise the impact of different amounts of paid work " + 
           "on care work. <br>A typical week of childcare has 7x14h = 98h when children do not go to daycare or school. ")

        let input_group = div.append("div")
          .attr("class", "inputs")
          .style("float", "left")
          .style("margin-top", "10px")
          .style("margin-bottom", "10px")
          .style("width", "100%")


        //append inputs
        input_group.selectAll("div")
          .data(input_data).enter()
          .append("div")
            .attr("class", d => d.text)
              .style("float", "left")
              .style("margin-right", "20px")
            .append("input")
              .attr("class", "text_input")
              .attr("type", "number")
              .attr("placeholder", "e.g. 40")
              .attr("min", 0)
              .attr("value", d => d.value)
              .attr("id", d => d.id)
              .style("margin", "12px 0px")
              .on("change", function() {
                numbers = [];
                sum = 0;
                load_hours_overview()
                load_hours_division()
              })
            
        input_group.selectAll("div")
          .insert("label", ":first-child")
            .attr("for", d => d.id)
            .text(d=> d.text)

        div.append("p")
          .attr("class", "summarise_input")
          .style("display", "block")

        

        div.append("svg")
          .attr("class", "working_svg")
          .style("display", "block")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("class", "working_hours")
            .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")")

        div.append("p")
          .attr("class", "between_svgs")
          .style("display", "block")
        
        div.append("div").attr("class", "division_div")
        .style("width", "100%")
        .style("float", "left")
        .style("display", "block");

        d3.select(".division_div").append("svg")
          .attr("class", "division_svg")
          .style("float", "left")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("class", "working_division")
            .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")");
          
        d3.select(".division_div").append("button")
          .attr("type", "button")
          .text("Reset to 50:50")
          .style("margin-top", margin.top + "px")
          .on("click", function() {
            total_percentage = 0.5;
            numbers = [];
            sum = 0;
            load_hours_overview();
            load_hours_division();});
              
        d3.select(".division_div").append("p")
        .attr("class", "hint")
        .style("font-size", "10px")
        .text("try moving the division line");
        
        div.append("p")
        .attr("class", "concl_division")
        .style("display", "block");
        

        
          d3.select(".working_svg").append("svg:defs")
            .selectAll("marker")
            .data(["start-arrow", "end-arrow"])
            .enter().append("marker")
            .attr("id", d => d)
            .attr("refX", 0)
            .attr("refY", 0)
            .attr("viewBox", "0 -5 10 10")
            .attr("markerWidth", 10)
            .attr("markerHeight", 10)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 0 -5 L 0 5")
            .style("stroke", "black")
            .style("stroke-width", 3);

          let x = d3.scaleLinear()
            .range([ 0, width]);
        
        
        load_hours_overview()
        load_hours_division()

        function load_hours_overview (){
        
          //working hours bar chart
          
          let stacked = [];
          for (let i = 0; i < 3; i++) {
            let value = Number(d3.select("#" + input_data[i].id).property("value"))
            
            if (i == 1) {//special calculation for childcare
              value = 98 - (5*value)
              stacked.push({
                "x_values": [sum, sum + value],
                "id": input_data[i].id
              });
            } else {
              // numbers.push({i: value});
              stacked.push({
                "x_values": [sum, sum + value],
                "id": input_data[i].id
              });
            } 
            numbers.push(value)
            sum = sum + value;
          }
          x.domain([0, sum]);

          div.select(".summarise_input")
          .html(`According to your input, person 1 does ${numbers[0]} hours of paid work and 
          person 2 does ${numbers[2]} hours. Substracting the ${d3.select("#" + input_data[1].id).property("value")} hours
          your child/children is/are in childcare or school everyday from the typical week, there is still
          98 - 5*${d3.select("#" + input_data[1].id).property("value")} = ${numbers[1]} hours of childcare to do.
          <br>The total working time (paid + care) is ${sum} hours.`)

          let g = d3.select(".working_hours")

          g.selectAll("rect")
            .data(stacked)
            .join("rect")
              .attr("x", d => x(d.x_values[0]))
              .attr("y", 0)
              .attr("height", height)
              .attr("width", d => x(d.x_values[1] - d.x_values[0]))
              .attr("fill", d => work_colour(d.id))
              .on("mouseover", function (event, d) {
                tooltip.style("visibility", "visible").text(d.id + ": " + Math.round(10*(d.x_values[1] - d.x_values[0]))/10 + " hours");
                d3.select(this)
                  .attr("fill", mntlld_red)
              })
              .on("mousemove", function (event, d) {
                tooltip.style("top", (event.pageY - 10) + "px")
                  .style("left", (event.pageX + 10) + "px");
              })
              .on("mouseout", function (event, d) {
                tooltip.style("visibility", "hidden");
                d3.select(this)
                  .attr("fill", work_colour(d.id));
              });
            
          g.selectAll(".label")
              .data(stacked)
              .join("text")
              .attr("class", "label")
              .attr("text-anchor", "middle")
              .attr("x", d => x( d.x_values[0] + (d.x_values[1] - d.x_values[0]) / 2))
              .attr("y", height/2)
              .attr("dy", ".35em")
              .text(d => (d.x_values[1] - d.x_values[0]) > 0 ? (d.x_values[1] - d.x_values[0]) : "");

            g.selectAll(".barlabel")
              .data(stacked)
              .join("text")
              .attr("class", "barlabel")
              .attr("text-anchor", "middle")
              .attr("x", d => x( d.x_values[0] + (d.x_values[1] - d.x_values[0]) / 2))
              .attr("y", 0)
              .attr("dy", "-.35em")
              .text(d => (d.x_values[1] - d.x_values[0]) > 0 ? d.id : "");

          
          g.selectAll(".line")
            .data([""])
            .join("line")
            //.attr("stroke-width",  3)
            // .attr("fill", "none")
            .attr("stroke", "black")
            .attr("marker-start", "url(#start-arrow)")
            .attr("marker-end", "url(#end-arrow)")
            .attr("x1", 0)
            .attr("x2", width)
            .attr("y1", height + 10)
            .attr("y2", height + 10)

          g.selectAll(".ann.axislabel")
            .data([""])
            .join("text")
            .attr("class", "ann axislabel")
            .attr("text-anchor", "middle")
            .attr("x", width/2)
            .attr("y", height + 25)
            .text(sum + " hours");
          
          // text in between
          div.select(".between_svgs")
          .html(`An equal distribution would leave each person with ${sum + "/2 = " + sum/2} working hours.`)
        }

        function load_hours_division (){
          //division hours bar chart
          
          let division_numbers = [];
          let half_hours = sum * total_percentage
          division_numbers[0] = numbers[0]
          division_numbers[1] = half_hours - numbers[0]
          division_numbers[2] = (sum-half_hours) - numbers[2]
          division_numbers[3] = numbers[2]
          
          let division_stacked = [];
          let j = 0;
            for (let i = 0; i < division_numbers.length; i++) {
              division_stacked.push({
                "x_values": [j, j + division_numbers[i]],
                "id": work_division_colour_ids[i]
              });
              j = j + division_numbers[i];
            }
          // console.log(division_numbers)
          // console.log(division_stacked)

          let g_division = d3.select(".working_division")
          g_division.selectAll("rect")
            .data(division_stacked)
            .join("rect")
              .attr("x", d => x(d.x_values[0]))
              .attr("y", 0)
              .attr("height", height)
              .attr("width", d => x(d.x_values[1] - d.x_values[0]))
              .attr("fill", d => work_division_colour(d.id))
              .on("mouseover", function (event, d) {
                tooltip.style("visibility", "visible").text(d.id + ": " + Math.round(10*(d.x_values[1] - d.x_values[0]))/10 + " hours");
                d3.select(this)
                  .attr("fill", mntlld_red)
              })
              .on("mousemove", function (event, d) {
                tooltip.style("top", (event.pageY - 10) + "px")
                  .style("left", (event.pageX + 10) + "px");
              })
              .on("mouseout", function (event, d) {
                tooltip.style("visibility", "hidden");
                d3.select(this)
                  .attr("fill", work_division_colour(d.id));
              });
   
            
          g_division.selectAll("text") //text in middle of rects
            .data(division_stacked)
            .join("text")
              .attr("class", "x axislabel")
              .attr("text-anchor", "middle")
              .attr("x", d => x( d.x_values[0] + (d.x_values[1] - d.x_values[0]) / 2))
              .attr("y", height/2)
              .attr("dy", ".35em")
              .text(d => (Math.round(10*(d.x_values[1] - d.x_values[0]))/10) > 0 ? Math.round(10*(d.x_values[1] - d.x_values[0]))/10 : "");

          
          g_division.selectAll(".labelline.top")
            .data([[0, width*total_percentage], [width*total_percentage, width]])
            .join("line")
            .attr("class","labelline top")
            .attr("stroke", "black")
            .attr("marker-start", "url(#start-arrow)")
            .attr("marker-end", "url(#end-arrow)")
            .attr("x1", d=>d[0])
            .attr("x2", d=>d[1])
            .attr("y1", -10)
            .attr("y2", -10);

            g_division.selectAll(".labelline.bottom")
            .data([[x(numbers[0]), width*total_percentage], [width*total_percentage, x(sum-numbers[2])]])
            .join("line")
            .attr("class","labelline bottom")
            .attr("stroke", "black")
            .attr("marker-start", "url(#start-arrow)")
            .attr("marker-end", "url(#end-arrow)")
            .attr("x1", d=>d[0])
            .attr("x2", d=>d[1])
            .attr("y1", height + 10)
            .attr("y2", height + 10);

          
          
          g_division.selectAll(".ann.axislabel.top")
            .data([ 
              // {"x": (width*total_percentage)/2,  "text": Math.round(10*sum*total_percentage)/10 + " hours"},
              // {"x":((width*total_percentage) + (width*(1-total_percentage))/2),  "text": Math.round(10*sum*(1-total_percentage))/10 + " hours"}
              {"x": (width*total_percentage)/2,  "text": Math.round(1000*total_percentage)/10 + "%"},
              {"x":((width*total_percentage) + (width*(1-total_percentage))/2),  "text": Math.round(1000*(1-total_percentage))/10 + "%"}
                  ])
            .join("text")
            .attr("class", "ann axislabel top")
            .attr("text-anchor", "middle")
            .attr("x", d => d.x)
            .attr("y", -18)
            .text(d => d.text);

          g_division.selectAll(".ann.axislabel.bottom")
            .data([ {"x": x(numbers[0] + division_numbers[1]/2),  "text":Math.round((1000*division_numbers[1]/numbers[1]))/10 + "%"},
                    {"x":x(numbers[0] + division_numbers[1] + division_numbers[2]/2),  "text": Math.round((1000*division_numbers[2]/(numbers[1])))/10 + "%"}
                  ])
            .join("text")
            .attr("class", "ann axislabel bottom")
            .attr("text-anchor", "middle")
            .attr("x", d => d.x)
            .attr("y", height + 25)
            .text(d => d.text);

          g_division.selectAll(".barlabel")
            .data([ { "x":width/4, "text": "Person 1"},
                    { "x": 0.75*width, "text": "Person 2"}])
            .join("text")
              .attr("class", "barlabel")
              .attr("text-anchor", "middle")
              .attr("x", d => d.x)
              .attr("y", -30)
              .attr("dy", "-.35em")
            .text(d=>d.text);
            
          // text in between
          div.select(".concl_division")
          .html(`This means that Person 1 would take on ${Math.round((1000*division_numbers[1]/(numbers[1])))/10}% of the childcare hours, which is an overall 
          of ${Math.round(total_percentage*1000)/10}% of all work.
          <br>
          And Person 2 does ${Math.round((1000*division_numbers[2]/(numbers[1])))/10}% of the childcare hours, which is an overall 
          of ${Math.round((1-total_percentage)*1000)/10}% of all working hours.
          <br> <b>Note:</b> Mental load is not necessarily tied to working hours because it can be performed in parallel with other tasks 
          (e.g., commuting can be combined with dinner planning).`) // TODO: put where?
        
          //division line between persons
        d3.select(".working_division").selectAll(".divisionline")
            .data([width*total_percentage])
            .join("line")
            .attr("stroke-width",  2.5)
            .attr("class","divisionline")
            .attr("stroke", "black")
            .attr("x1", d=>d)
            .attr("x2", d=>d)
            .attr("y1", 0)
            .attr("y2", height)
            .style("cursor", "col-resize")
    
        } 

        //division line interactivity
        d3.select(".divisionline")
            .call(d3.drag().on("drag", function (event, d) {
                  d3.select(this)
                   .attr("x1", Math.min(Math.max(event.x, x(numbers[0])), x(sum-numbers[2])));
                   d3.select(this)
                   .attr("x2", Math.min(Math.max(event.x, x(numbers[0])), x(sum-numbers[2])));
                   total_percentage = (Math.min(Math.max(event.x, x(numbers[0])), x(sum-numbers[2]))/width)
                   load_hours_division()
        }))
      }


      function build_restructuring() {
        d3.select("body").append("p").html("We recommend talking to your partner to discuss your results and to find a " +
          "division of mental load that fits both of you." + 
          // "You can use this tool to answer the question 'How would the scoring change if I also take on this task?'" + 
          "<br> You can use this tool to see how a redistribution would change your score. " +
          "The dark grey buttons indicate your answers from the test. Click on buttons for either 'I-do-it' or 'I-remember' to reassign a task. " + 
          "To the right, your scoring chart will update accordingly. " + 
          "You can for example see how many tasks would have to be redistributed to achieve an equal result. " +
          "Use the reset button to return to the original result. "
        )


        let grouped_by_domain = d3.group(valid_questions, d => d.domain)
        let counts = [];

        grouped_by_domain.forEach((value, key) => {
          let count = value.length;
          counts.push(count)
        });

        //compute height of svg
        let item_height = 24;
        let button_width = 55;
        // let req_height = (max_count + 1) * item_height + (max_count + 1) * 5;
        let margin = { top: 40, right: 40, bottom: 20, left: 20, between: 30 };
        let width = 550 - margin.left - margin.right;
        let heights = counts.map((x) => (x + 1) * item_height + (x + 1) * 5);
        

        // create svg
        d3.select("body").append("div").attr("class", "restructuring").style("height", (heights[0] + heights[1]+heights[2] + 3*margin.top + 3*margin.bottom ) + "px")
        

        let domain_svg = d3.select(".restructuring").append("div")
            .attr("class", "list")
            .style("width", (width + margin.left + margin.right) + "px")
            .style("float", "left")
          .selectAll(".domaingroup")
          .data(grouped_by_domain)
          .join("svg")
          .attr("class", "domaingroup")
          .attr("width", width + margin.left + margin.right)
          .attr("height", (d,i) => heights[i] + margin.top + margin.bottom)
          .append("g")
            .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")")
            .attr("class", "group_restructuring")
          
        domain_group = d3.selectAll(".group_restructuring")
        //title for domain group
        domain_group.append("text")
          .attr("class", "chart_title")
          .attr("x", 10)
          .attr("y", -35 )
          .attr("dy", ".35em")
          .text(d=> d[0])

        domain_group.selectAll(".descr")
          .data([
            {"x": width-(1.5*button_width), "text": "I-do-it"},
            {"x": width-(.5*button_width), "text": "I-remember"},
          ])
          .join("text")
          .attr("class", "descr")
          .attr("x", d => d.x)
          .attr("y", -12 )
          .attr("dy", ".35em")
          .style("font-size", "11px")
          .attr("text-anchor", "middle")
          .text(d => d.text)


        let items = d3.selectAll(".group_restructuring")
        .selectAll(".item")
        .data(([,d]) => d)
        .join("g")
        .attr("class", "item")


        
        items.append("text")
          .attr("class", "label")
          .attr("x", 20)
          .attr("y", (d,i) => ((i+0.5) * item_height) + i*5 )
          .attr("dy", ".35em")
          // .text(function(d) { console.log(d.Text.substring(0, 24) + "...")})
          .text(function(d) { 
            // console.log(d.Text.length > 40?d.Text.substring(0, 39) + "...":d.Text);
            return d.Text.length > 55?d.Text.substring(0, 54) + "...":d.Text;
          })

        update_rect_buttons()
        function update_rect_buttons() {
          //I_do_it buttons
          d3.selectAll("rect.i_do").remove()
          d3.selectAll("rect.i_remember").remove()
          d3.selectAll("#point_change").remove()
          d3.selectAll("#point_change_rem").remove()

          
          items.append("rect")
            .attr("class", "i_do")
            .attr("x", width-(2*button_width))
            .attr("y", (d,i) => (i * item_height) + i*5 )
            .attr("height", item_height)
            .attr("width", button_width)
            .attr("fill-opacity", "1")
            .style("cursor", "pointer")
            .attr("fill", function (d) {
              if(d.I_do_it) {
                return mntlld_dark_grey //color(d.rhythm)
              } else {
                return "#f2f2f2"
              }
            })
            .on("mouseover", function (event, d) {
              d3.select(this)
                .attr("fill-opacity", "0.4")
            })
            .on("mouseout", function (event, d) {
              d3.select(this).attr("fill-opacity", "1");
            })
            .on("mousedown", function (event, d) {
              d3.select(this)
                .attr("fill-opacity", "0.9")
            })
            .on("mouseup", function (event, d) {
              d3.select(this)
                .attr("fill-opacity", "0.4")
                .attr("fill", function (d) {
                  if (d.I_do_it_restr | 0) {
                    if(d.I_do_it) {
                      d3.select(this.parentNode)
                      .append("text")
                      .attr("id", "point_change")
                      .attr("x", width - (1.5 * button_width))
                      .attr("y", d3.select(this.parentNode).select(".label").attr("y"))
                      .attr("dy", d3.select(this.parentNode).select(".label").attr("dy"))
                      .attr("text-anchor","middle" )
                      .text(d => "-" + d.points)
                      d.I_do_it_restr = false;
                      update_bars()
                      return mntlld_lightred
                    } else {
                      d3.select(this.parentNode).select("#point_change").remove()
                      d.I_do_it_restr = "none";
                      update_bars()
                      return "#f2f2f2"
                    }
                  } else if(d.I_do_it_restr == false) {
                    if(d.I_do_it) {
                      d3.select(this.parentNode).select("#point_change").remove()
                      d.I_do_it_restr = "none";
                    } else {
                      d3.select(this.parentNode)
                        .append("text")
                        .attr("id", "point_change")
                        .attr("x", width - (1.5 * button_width))
                        .attr("y", d3.select(this.parentNode).select(".label").attr("y"))
                        .attr("dy", d3.select(this.parentNode).select(".label").attr("dy"))
                        // .attr("fill", function(d) {return d.rhythm == rhythms[0]? "white": "black"})
                        .attr("text-anchor","middle" )
                        .text(d => "+" + d.points)
                        d.I_do_it_restr = true;
                    }
                    update_bars()
                    return mntlld_dark_grey //color(d.rhythm)
                  } else if(!d.I_do_it) {
                    d3.select(this.parentNode)
                        .append("text")
                        .attr("id", "point_change")
                        .attr("x", width - (1.5 * button_width))
                        .attr("y", d3.select(this.parentNode).select(".label").attr("y"))
                        .attr("dy", d3.select(this.parentNode).select(".label").attr("dy"))
                        // .attr("fill", function(d) {return d.rhythm == rhythms[0]? "white": "black"})
                        .attr("text-anchor","middle" )
                        .text(d => "+" + d.points)
                    d.I_do_it_restr = true;
                    update_bars()
                    return color(d.rhythm)
                  } else if (d.I_do_it) {
                    d3.select(this.parentNode)
                        .append("text")
                        .attr("id", "point_change")
                        .attr("x", width - (1.5 * button_width))
                        .attr("y", d3.select(this.parentNode).select(".label").attr("y"))
                        .attr("dy", d3.select(this.parentNode).select(".label").attr("dy"))
                        .attr("text-anchor","middle" )
                        .text(d => "-" + d.points)
                    d.I_do_it_restr = false;
                    update_bars()
                    return mntlld_lightred //"#f2f2f2" //"#bdbdbd"
                  }
                })
            });

          //I_remember buttons
          items.append("rect")
            .attr("class", "i_remember")
            .attr("x", width-(button_width))
            .attr("y", (d,i) => (i * item_height) + i*5 )
            .attr("height", item_height)
            .attr("width", button_width)
            .attr("fill-opacity", "1")
            .style("cursor", "pointer")
            .attr("fill", function (d) {
              if(d.I_remember) {
                return mntlld_dark_grey// color(d.rhythm)
              } else {
                return "#f2f2f2" //"#bdbdbd"
              }
            })
            .on("mouseover", function (event, d) {
              d3.select(this)
                .attr("fill-opacity", "0.4")
            })
            .on("mouseout", function (event, d) {
              d3.select(this).attr("fill-opacity", "1");
            })
            .on("mousedown", function (event, d) {
              d3.select(this)
                .attr("fill-opacity", "0.9")
            })
            .on("mouseup", function (event, d) {
              d3.select(this)
                .attr("fill-opacity", "0.4")
                .attr("fill", function (d) {
                  if (d.I_remember_restr | 0) {
                    if(d.I_remember) {
                      d3.select(this.parentNode)
                        .append("text")
                        .attr("id", "point_change_rem")
                        .attr("x", width - (.5 * button_width))
                        .attr("y", d3.select(this.parentNode).select(".label").attr("y"))
                        .attr("dy", d3.select(this.parentNode).select(".label").attr("dy"))
                        .attr("text-anchor","middle" )
                        .text(d => "-" + d.points)
                        d.I_remember_restr = false;
                        update_bars()
                        return mntlld_lightred
                    } else {
                      d3.select(this.parentNode).select("#point_change_rem").remove()
                      d.I_remember_restr = "none";
                      update_bars()
                      return "#f2f2f2"
                    }
                  } else if(d.I_remember_restr == false) {
                    if(d.I_remember) {
                      d3.select(this.parentNode).select("#point_change_rem").remove()
                      d.I_remember_restr = "none";
                    } else {
                      d3.select(this.parentNode)
                        .append("text")
                        .attr("id", "point_change_rem")
                        .attr("x", width - (.5 * button_width))
                        .attr("y", d3.select(this.parentNode).select(".label").attr("y"))
                        .attr("dy", d3.select(this.parentNode).select(".label").attr("dy"))
                        // .attr("fill", function(d) {return d.rhythm == rhythms[0]? "white": "black"})
                        .attr("text-anchor","middle" )
                        .text(d => "+" + d.points)
                      d.I_remember_restr = true;
                    }
                    update_bars()
                    return mntlld_dark_grey//color(d.rhythm)
                  } else if(!d.I_remember) {
                    d3.select(this.parentNode)
                        .append("text")
                        .attr("id", "point_change_rem")
                        .attr("x", width - (.5 * button_width))
                        .attr("y", d3.select(this.parentNode).select(".label").attr("y"))
                        .attr("dy", d3.select(this.parentNode).select(".label").attr("dy"))
                        .attr("text-anchor","middle" )
                        // .attr("fill", function(d) {return d.rhythm == rhythms[0]? "white": "black"})
                        .text(d => "+" + d.points)
                    d.I_remember_restr = true;
                    update_bars()
                    return color(d.rhythm) //mntlld_green 
                  } else if (d.I_remember) {
                    d3.select(this.parentNode)
                        .append("text")
                        .attr("id", "point_change_rem")
                        .attr("x", width - (.5 * button_width))
                        .attr("y", d3.select(this.parentNode).select(".label").attr("y"))
                        .attr("dy", d3.select(this.parentNode).select(".label").attr("dy"))
                        .attr("text-anchor","middle" )
                        .text(d => "-" + d.points)
                    d.I_remember_restr = false;
                    update_bars()
                    return mntlld_lightred //"#f2f2f2" //"#bdbdbd"
                  }
                })
            });

            d3.selectAll("#border").raise()
        }


        //rhythm rects
        items.append("rect")
          .attr("x", 0)
          .attr("y", (d,i) => (i * item_height) + i*5 )
          .attr("height", item_height)
          .attr("width", 15)
          .attr("fill", d => color(d.rhythm))
          

        items.append("rect")
          .attr("id", "border")
          .attr("stroke", "black")
          .attr("x", 0)
          .attr("y", (d,i) => (i * item_height) + i*5 )
          .attr("height", item_height)
          .attr("width", width)
          .attr("fill", "none")
          .attr("stroke-width", 1);


        /////////////////////////////// restructured overview barchart//////////////////////////////////////
        let margin_bar = { top: 40, right: 40, bottom: 40, left: 50 };
        let width_bar = 450 - margin_bar.left - margin_bar.right;
        let height_bar = 400 - margin_bar.top - margin_bar.bottom;
        
        let svg2 = d3.select(".restructuring")
            .append("div")
            .attr("class", "restr_overview")
            .style("position", "sticky").style("top", 0)
            .style("margin-left", (width + margin.left + margin.right) + "px")
            .append("svg")
            .style("display", "block")
            .attr("class", "overview_svg")
            .attr("width", width_bar + margin_bar.left + margin_bar.right)
            .attr("height", height_bar + margin_bar.top + margin_bar.bottom)
            // .text(function(d) {console.log(remove_weird_symbols(d[0]))})
            //.text(function(d) {console.log(d[0]);})
            .append("g")
            .attr("transform",
              "translate(" + margin_bar.left + "," + margin_bar.top + ")")
            .attr("class", "group_overview")

        svg2.append("g").attr("class", "bars")
        // X axis
        let x = d3.scaleBand()
          .range([0, width_bar])
          .domain(types)
          .padding(0.2);


        // Add Y axis
        //initial with max number of points for daily tasks
        let y = d3.scaleLinear()
          .domain([0, 1.1 * max_num_points])
          .range([height_bar, 0]);

        let yAxis = svg2.append("g")
          .attr("class", "myYaxis")
          .call(d3.axisLeft(y));

        //yAxis label
        svg2.append("text")
          .attr("class", "y axislabel")
          .attr("text-anchor", "end")
          .attr("y", -20)
          .attr("dy", ".75em")
          //.attr("transform", "translate(-40," + height/2 + "),rotate(-90)")
          .text("points");
          let rolled_up_I_do_it = d3.rollup(valid_questions, v => d3.sum(v, d => d.points), d => d.I_do_it)
          let rolled_up_I_remember = d3.rollup(valid_questions, v => d3.sum(v, d => d.points), d => d.I_remember)

          let data_overview = [
            { "type": "I_do_it", "value": rolled_up_I_do_it.get(true), "restructure": false},
            { "type": "I_remember", "value": rolled_up_I_remember.get(true), "restructure": false},
                      ];

          svg2.select(".bars")
            .selectAll(".org_bar")
            .data(data_overview)
            .join("rect")
              .attr("class", "org_bar")
              .attr("x", function (d) { return x(d.type); })
              .attr("y", function (d) { return y(d.value); })
              //.text(function(d) {console.log(d.type);})
              .attr("width", x.bandwidth())
              .attr("height", function (d) { return height_bar - y(d.value); })
              .attr("fill", mntlld_dark_grey)
              .on("mouseover", function (event, d) {
                tooltip.style("visibility", "visible").text(d.value + " Points");
                d3.select(this).attr("fill", mntlld_red)
              })
              .on("mousemove", function (event, d) {
                tooltip.style("top", (event.pageY - 10) + "px")
                  .style("left", (event.pageX + 10) + "px");
              })
              .on("mouseout", function (event, d) {
                d3.select(this).attr("fill", mntlld_dark_grey);
                tooltip.style("visibility", "hidden");
              });

        //add 50% line
        svg2.selectAll(".dashed_line")
          .data([max_num_points / 2, max_num_points])
          .join("line")
          .attr("class", "dashed_line")
          .attr("x1", 0)
          .attr("x2", width_bar)
          .attr("y1", d => y(d))
          .attr("y2", d => y(d));

        update_bars()
        function update_bars() {

          let rolled_up_I_do_it_restr = d3.rollup(valid_questions, v => d3.sum(v, d => d.points), d => d.I_do_it_restr)
          let rolled_up_I_remember_restr = d3.rollup(valid_questions, v => d3.sum(v, d => d.points), d => d.I_remember_restr)
          let data_restr = [
            { "type": "I_do_it", "value": (rolled_up_I_do_it_restr.get(true) | 0) - (rolled_up_I_do_it_restr.get(false) | 0), "restructure": true },
            { "type": "I_remember", "value": (rolled_up_I_remember_restr.get(true) | 0)  - (rolled_up_I_remember_restr.get(false) | 0), "restructure": true },
          ];

          svg2.select(".bars")
            .selectAll(".restr_bar")
            .data(data_restr)
            .join("rect")
              .attr("class", "restr_bar")
              .attr("x", function (d) { return x(d.type); })
              .transition()
                .duration(400)
                .ease(d3.easeLinear)
              .attr("y", function (d,i) { return d.value >= 0 ? y(data_overview[i].value + d.value) : y(data_overview[i].value); }) 
              //.text(function(d) {console.log(d.type);})
              .attr("width", x.bandwidth())
              // .attr("height", function (d) { d.value >= 0 ? (height_bar - y(d.value)) : (height_bar - y(Math.abs(d.value))); })
              .attr("height", function (d) { return height_bar - y(Math.abs(d.value)); })
              .attr("fill", function(d) { return d.value >= 0 ? mntlld_lightblue : mntlld_lightred})


        svg2.selectAll(".restr_bar")
              .on("mouseover", function (event, d) {
                tooltip.style("visibility", "visible").text(d.value + " Points");
                d3.select(this).attr("fill", mntlld_red)
              })
              .on("mousemove", function (event, d) {
                tooltip.style("top", (event.pageY - 10) + "px")
                  .style("left", (event.pageX + 10) + "px");
              })
              .on("mouseout", function (event, d) {
                d3.select(this).attr("fill", mntlld_lightblue);
                tooltip.style("visibility", "hidden");
              });

          //add bar labels
          let sum_done_points = done_points + data_restr[0].value
          let sum_remembered_points = I_remembered_points + data_restr[1].value
          svg2
            .selectAll("text.sum")
            .data([{ "sum": sum_done_points, "type": "I_do_it" }, { "sum": sum_remembered_points, "type": "I_remember" }])
            .join("text")
            .attr("class", "sum")
            //.text(function(d) {console.log(d)})
            .attr("x", (d) => x(d.type) + x.bandwidth() / 2)
            .transition()
              .duration(400)
              .ease(d3.easeLinear)
            .attr("y", (d) => y(d.sum))
            .attr("dy", "-1em")
            .style("text-anchor", "middle")
            .text(d => d.sum);

          //add difference labels
          svg2
            .selectAll("text.diff.label")
            .data([
              { "sum": data_restr[0].value, "type": "I_do_it", "position": done_points + 0.5*data_restr[0].value},
              { "sum": data_restr[1].value, "type": "I_remember", "position": I_remembered_points + 0.5*data_restr[1].value}])
            .join("text")
            .attr("class", "diff label")
            //.text(function(d) {console.log(d)})
            .attr("x", (d) => x(d.type) + x.bandwidth() + 4)
            .transition()
              .duration(400)
              .ease(d3.easeLinear)
            .attr("y", (d) => y(d.position))
            .attr("dy", ".35em")
            .text(function(d) {
              if (d.sum > 0){ 
                return "+" + Math.abs(d.sum)
              } else if (d.sum < 0){ 
                return "-" + Math.abs(d.sum)
              }
              else {
                return ""
              }
              
              });



        
        }

        

        //line labels
        svg2.append("g").attr("class", "line_labels")
          .selectAll("label")
          .data([
            { "value": max_num_points / 2, "text": "50% of reachable points" },
            { "value": max_num_points, "text": "reachable points: " + max_num_points }
          ])
          .join("text")
          .attr("class", "label")
          .attr("x", width_bar)
          .attr("y", d => y(d.value))
          .attr("dy", "-.35em")
          .style("text-anchor", "end")
          .text(d => d.text);
        
        //x-Axis on top
        svg2.append("g")
          .attr("transform", "translate(0," + height_bar + ")")
          .call(d3.axisBottom(x));


        ///////////////////////////    reset button /////////////////////////

        d3.select(".restr_overview").append("button")
          .attr("type", "button")
          .style("margin-left", "165px")
          .text("Reset to test result")
          .style("margin-top", margin.top + "px")
          .on("click", function() {
            valid_questions.forEach((item) => {
              item.I_do_it_restr = "none";
              item.I_remember_restr = "none";
            });
            update_rect_buttons();
            update_bars();
            ;});

        // d3.select(".list").raise()
        
      
      }
      //#endregion


      //#region                            #################   functions ##################

      function aggregate_data(data, grouping, person = "me") {
        switch (person) {
          case "me":
            var type_to_use = types
            break;

          case "partner":
            var type_to_use = partner_types
            break;
        }

        let aggregatedData = {
          [type_to_use[0]]: {},
          [type_to_use[1]]: {}
        };
        data.forEach(d => {
          if (d[type_to_use[0]]) {
            aggregatedData[type_to_use[0]][d[grouping]] = (aggregatedData[type_to_use[0]][d[grouping]] || 0) + d.points;
          }
          if (d[type_to_use[1]]) {
            aggregatedData[type_to_use[1]][d[grouping]] = (aggregatedData[type_to_use[1]][d[grouping]] || 0) + d.points;
          }
        });
        let categories = Object.keys(aggregatedData[type_to_use[0]]).concat(Object.keys(aggregatedData[type_to_use[1]])).filter((value, index, self) => self.indexOf(value) === index);



        let formattedData = type_to_use.map(type => {
          const obj = { type };
          categories.forEach(category => {
            obj[category] = aggregatedData[type][category] || 0;
          });
          return obj;
        });


        return [formattedData, type_to_use, categories]
      }



      function remove_weird_symbols(str) {
        return str.replace(/\s/g, "").replace("-", "").replace(",", "").replace("+", "")
      }

      function normaliseMap(map) {
        let map1 = map.get(true);
        let map2 = map.get(false);
        let normalised = new Map ()
        for (let [key, value] of map2.entries()) {
          if(typeof value === 'number') {
            if (map1.has(key)) {
              if (value >= 0) {
                normalised.set(key, (100*(map1.get(key) / (map1.get(key) + value))) | 0);
              } else {
                normalised.set(key, (-100*(map1.get(key) / (map1.get(key) + value))) | 0);
              }
            } else {
              normalised.set(key, 0);
            }
          } else {
            normalised.set(key, new Map())
            for (let [inner_key, value_inner] of value.entries()) {
              if (map1.has(key)) {
                normalised.get(key).set(inner_key, (100*(map1.get(key).get(inner_key) / (map1.get(key).get(inner_key) + value_inner))) | 0);
              } else {
                normalised.get(key).set(inner_key, 0);
              }
            }
          }
        }
        return normalised;
        
      }

      function normaliseAndSpecify(map) {
        let map1 = map.get(true);
        let map2 = map.get(false);
        let normalised = new Map ()
        for (let [key, value] of map2.entries()) {
          if(typeof value === 'number') {
            if (map1.has(key)) {
              if (value >= 0) {
                normalised.set(key, [0, ((100*(map1.get(key) / (map1.get(key) + value))) | 0)]);
              } else {
                normalised.set(key, [((-100*(map1.get(key) / (map1.get(key) + value))) | 0), 0]);
              }
            } else {
              normalised.set(key, [0, 0]);
              
            }
          } else {
            normalised.set(key, new Map())
            for (let [inner_key, value_inner] of value.entries()) {
              if (map1.has(key)) {
                if (value_inner >= 0) {
                  normalised.get(key).set(inner_key, [0, ((100*(map1.get(key).get(inner_key) / (map1.get(key).get(inner_key) + value_inner))) | 0)]);
                } else {
                  normalised.get(key).set(inner_key, [((-100*(map1.get(key).get(inner_key) / (map1.get(key).get(inner_key) + value_inner))) | 0), 0]);
                }
              } else {
                normalised.get(key).set(inner_key, [0,0]);
              }
            }
          }
        }
        return normalised;
        
      }

      function sortInnerMaps(nestedMap) {
        let sortedOuterMap = new Map();
        for (let [outerKey, innerMap] of nestedMap.entries()) {
          // Sort the inner map by its keys
          let sortedInnerMap = new Map([...innerMap.entries()].sort((a, b) => b[1] - a[1]));
          sortedOuterMap.set(outerKey, sortedInnerMap);
        }
        return sortedOuterMap;
      }


      //#endregion
    })

    // .catch(function (error) {
    //   // handle error
    //   console.log(error)
    // });

  </script>




</body>

</html>